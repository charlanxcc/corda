package net.corda.carpenter

import net.corda.core.serialization.CordaSerializable
import net.corda.core.serialization.amqp.*
import org.junit.Test
import kotlin.test.assertEquals

/*******************************************************************************************************/

@CordaSerializable
interface J {
    val j : Int
}

/*******************************************************************************************************/

@CordaSerializable
interface I {
    val i : Int
}

@CordaSerializable
interface II {
    val ii : Int
}

@CordaSerializable
interface III : I {
    val iii : Int
    override val i: Int
}

@CordaSerializable
interface IIII {
    val iiii : Int
    val i    : I
}

/*******************************************************************************************************/

class InheritanceSchemaToClassCarpenterTests {
    private var factory = SerializerFactory()

    fun serialise(clazz: Any) = SerializationOutput(factory).serialize(clazz)

    fun curruptName(name: String) = "${name}__carpenter"

    /* given a list of class names work through the amqp envelope schema and alter any that
       match in the fashion defined above */
    fun curruptName (schema: Schema, names: List<String>) : Schema {
        val types = schema.types

        val newTypes : MutableList<TypeNotation> = mutableListOf()

        for (type in types) {
            val newName = if (type.name in names) curruptName (type.name) else type.name

            val newProvides = type.provides.map {
                it -> if (it in names) curruptName (it) else it
            }

            val newFields = (type as CompositeType).fields.map {
                it -> if ( it.requires.isNotEmpty() && it.requires[0] in names)
                    it.copy (requires=listOf (curruptName (it.requires[0]))) else it
            }

            newTypes.add (type.copy (name=newName, provides=newProvides, fields=newFields))
        }

        return Schema (types=newTypes)
    }

    @Test
    fun interfaceParent1() {
        val testJ = 20
        val testName = "interfaceParent1"

        class A(override val j: Int) : J

        val a = A(testJ)

        assertEquals(testJ, a.j)

        val obj = DeserializationInput(factory).deserializeRtnEnvelope(serialise(a))

        assert(obj.first is A)

        val serSchema = obj.second.schema

        assertEquals(2, serSchema.types.size)

        val l1 = serSchema.carpenterSchema()

        /* since we're using an envelope generated by seilaising classes defined locally
           it's extremely unlikely we'd need to carpent any classes */
        assertEquals(0, l1.size)

        val curruptSchema = curruptName (serSchema, listOf ("${this.javaClass.name}\$$testName\$A"))

        val l2 = curruptSchema.carpenterSchema()

        assertEquals(1, l2.size)

        assertEquals(curruptName("${this.javaClass.name}\$$testName\$A"), l2[0].name)
        assertEquals(1, l2[0].interfaces.size)
        assertEquals(net.corda.carpenter.J::class.java, l2[0].interfaces[0])

        val aBuilder = ClassCarpenter().build(l2[0])

        val objJ = aBuilder.constructors[0].newInstance(testJ)
        val j = objJ as J

        assertEquals(aBuilder.getMethod("getJ").invoke(objJ), testJ)
        assertEquals(a.j, j.j)
    }


    @Test
    fun interfaceParent2() {
        val testJ = 20
        val testJJ = 40
        val testName = "interfaceParent2"

        class A(override val j: Int, val jj: Int) : J

        val a = A(testJ, testJJ)

        assertEquals(testJ, a.j)
        assertEquals(testJJ, a.jj)

        val obj = DeserializationInput(factory).deserializeRtnEnvelope(serialise(a))

        assert(obj.first is A)

        val serSchema = obj.second.schema

        assertEquals(2, serSchema.types.size)

        val l1 = serSchema.carpenterSchema()

        /* since we're using an envelope generated by seilaising classes defined locally
           it's extremely unlikely we'd need to carpent any classes */
        assertEquals(0, l1.size)

        val curruptSchema = curruptName (serSchema, listOf ("${this.javaClass.name}\$$testName\$A"))

        val l2 = curruptSchema.carpenterSchema()

        assertEquals(1, l2.size)

        assertEquals(curruptName("${this.javaClass.name}\$$testName\$A"), l2[0].name)
        assertEquals(1, l2[0].interfaces.size)
        assertEquals(net.corda.carpenter.J::class.java, l2[0].interfaces[0])

        val aBuilder = ClassCarpenter().build(l2[0])

        val objJ = aBuilder.constructors[0].newInstance(testJ, testJJ)
        val j = objJ as J

        assertEquals(aBuilder.getMethod("getJ").invoke(objJ), testJ)
        assertEquals(aBuilder.getMethod("getJj").invoke(objJ), testJJ)

        assertEquals(a.j, j.j)
    }

    @Test
    fun multipleInterfaces() {
        val testI  = 20
        val testII = 40
        val testName = "multipleInterfaces"

        class A(override val i: Int, override val ii: Int) : I, II

        val a  = A(testI, testII)
        val obj = DeserializationInput(factory).deserializeRtnEnvelope(serialise(a))

        assert(obj.first is A)

        val serSchema = obj.second.schema

        assertEquals(3, serSchema.types.size)

        val l1 = serSchema.carpenterSchema()

        /* since we're using an envelope generated by seilaising classes defined locally
           it's extremely unlikely we'd need to carpent any classes */
        assertEquals(0, l1.size)

        /* pretend we don't know the class we've been sent, i.e. it's unknown to the class loader, and thus
           needs some carpentry */

        val curruptSchema = curruptName (serSchema, listOf ("${this.javaClass.name}\$$testName\$A"))
        val l2 = curruptSchema.carpenterSchema()

        assertEquals(1, l2.size)

        assertEquals(curruptName("${this.javaClass.name}\$$testName\$A"), l2[0].name)
        assertEquals(2, l2[0].interfaces.size)
        assert (net.corda.carpenter.I::class.java in l2[0].interfaces)
        assert (net.corda.carpenter.II::class.java in l2[0].interfaces)

        val aBuilder = ClassCarpenter().build(l2[0])

        val objA = aBuilder.constructors[0].newInstance(testI, testII)
        val i  = objA as I
        val ii = objA as II

        assertEquals(aBuilder.getMethod("getI").invoke(objA), testI)
        assertEquals(aBuilder.getMethod("getIi").invoke(objA), testII)

        assertEquals(a.i,  i.i)
        assertEquals(a.ii, ii.ii)
    }

    @Test
    fun nestedInterfaces() {
        val testI    = 20
        val testIII  = 60
        val testName = "nestedInterfaces"

        class A(override val i: Int, override val iii : Int) : III

        val a  = A(testI, testIII)
        val obj = DeserializationInput(factory).deserializeRtnEnvelope(serialise(a))

        assert(obj.first is A)

        val serSchema = obj.second.schema

        assertEquals(3, serSchema.types.size)

        val l1 = serSchema.carpenterSchema()

        /* since we're using an envelope generated by seilaising classes defined locally
           it's extremely unlikely we'd need to carpent any classes */
        assertEquals(0, l1.size)

        val curruptSchema = curruptName (serSchema, listOf ("${this.javaClass.name}\$$testName\$A"))
        val l2 = curruptSchema.carpenterSchema()

        assertEquals(1, l2.size)

        assertEquals(curruptName("${this.javaClass.name}\$$testName\$A"), l2[0].name)
        assertEquals(2, l2[0].interfaces.size)
        assert (net.corda.carpenter.I::class.java in l2[0].interfaces)
        assert (net.corda.carpenter.III::class.java in l2[0].interfaces)

        val aBuilder = ClassCarpenter().build(l2[0])

        val objA = aBuilder.constructors[0].newInstance(testI, testIII)
        val i   = objA as I
        val iii = objA as III

        assertEquals(aBuilder.getMethod("getI").invoke(objA), testI)
        assertEquals(aBuilder.getMethod("getIii").invoke(objA), testIII)

        assertEquals(a.i,   i.i)
        assertEquals(a.i,   iii.i)
        assertEquals(a.iii, iii.iii)
    }

    @Test
    fun memberInterface() {
        val testI     = 25
        val testIIII  = 50
        val testName = "memberInterface"

        class A(override val i: Int) : I
        class B(override val i : I, override val iiii : Int) : IIII

        val a = A(testI)
        val b = B(a, testIIII)

        val obj = DeserializationInput(factory).deserializeRtnEnvelope(serialise(b))

        assert(obj.first is B)

        val serSchema = obj.second.schema

        /*
         * class A
         * class A's interface (class I)
         * class B
         * class B's interface (class IIII)
         */
        assertEquals(4, serSchema.types.size)

        val curruptSchema = curruptName (serSchema, listOf ("${this.javaClass.name}\$$testName\$A",
                "${this.javaClass.name}\$$testName\$B"))

        val cSchema = curruptSchema.carpenterSchema()
        assertEquals(2, cSchema.size)

        val aCarpenterSchema = cSchema.find { it.name == curruptName("${this.javaClass.name}\$$testName\$A") }
        val bCarpenterSchema = cSchema.find { it.name == curruptName("${this.javaClass.name}\$$testName\$B") }

        assert(aCarpenterSchema != null)
        assert(bCarpenterSchema != null)

        val cc  = ClassCarpenter()
        val cc2 = ClassCarpenter()

        val bBuilder = cc.build(bCarpenterSchema!!)
        bBuilder.constructors[0].newInstance(a, testIIII)

        val aBuilder = cc.build(aCarpenterSchema!!)
        val objA = aBuilder.constructors[0].newInstance(testI)

        /* build a second B this time using our constructed instane of A and not the
           local one we pre defined */
        bBuilder.constructors[0].newInstance(objA, testIIII)

        /* whittle and instantiate a different A with a new class loader */
        val aBuilder2 = cc2.build(aCarpenterSchema)
        val objA2 = aBuilder2.constructors[0].newInstance(testI)

        bBuilder.constructors[0].newInstance(objA2, testIIII)
    }

    /* this time remove the nested interface from out set of known classes forcing us
       to whittle it */
    @Test
    fun memberInterface2() {
        val testI     = 25
        val testIIII  = 50
        val testName = "memberInterface2"

        class A(override val i: Int) : I
        class B(override val i : I, override val iiii : Int) : IIII

        val a = A(testI)
        val b = B(a, testIIII)

        val obj = DeserializationInput(factory).deserializeRtnEnvelope(serialise(b))

        assert(obj.first is B)

        val serSchema = obj.second.schema

        /*
         * The classes we're expecting to find:
         *   class A
         *   class A's interface (class I)
         *   class B
         *   class B's interface (class IIII)
         */
        assertEquals(4, serSchema.types.size)

        val curruptSchema = curruptName (serSchema, listOf (
                "${this.javaClass.name}\$$testName\$A",
                "${this.javaClass.getPackage().name}.I"))


        val carpenterSchema = curruptSchema.carpenterSchema()

        val aCarpenterSchema = carpenterSchema.find { it.name == curruptName("${this.javaClass.name}\$$testName\$A") }
//        val bCarpenterSchema = carpenterSchema.find { it.name == curruptName("${this.javaClass.getPackage().name}.I") }

        val cc = ClassCarpenter()

        val aBuilder = cc.build (aCarpenterSchema!!)
        aBuilder.constructors[0].newInstance(testI)


        /*

        var cc2 = ClassCarpenter()

        var bBuilder = cc.build(bCarpenterSchema!!)
        val objB = bBuilder.constructors[0].newInstance(a, testIIII)

        var aBuilder = cc.build(aCarpenterSchema!!)
        val objA = aBuilder.constructors[0].newInstance(testI)

        /* build a second B this time using our constructed instane of A and not the
           local one we pre defined */
        val objB2 = bBuilder.constructors[0].newInstance(objA, testIIII)

        /* whittle and instantiate a different A with a new class loader */
        var aBuilder2 = cc2.build(aCarpenterSchema!!)
        val objA2 = aBuilder2.constructors[0].newInstance(testI)

        val objB3 = bBuilder.constructors[0].newInstance(objA2, testIIII)
        */
    }

}


